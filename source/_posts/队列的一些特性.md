---
title: 队列的一些特性
date: 2019-06-05 17:42:12
tags: RabbitMQ
categories: 中间件

---

## 队列的长度限制

队列可以被设置大小，包括：队列中最大容纳的消息数目以及队列中容纳消息的最大总字节数。这两个值可以通过队列的参数 (`x-max-length` 和 `x-max-length-bytes`) 以及 `policy` (`max-length` 和 `max-length-bytes`) 来设置。 

- `max-length` | `x-max-length` 表示队列中容纳的最多消息**个数**
- `max-length-bytes` | `x-max-length-bytes` 表示队列中的消息最大**总字节数**

默认情况下，当设置了容量的队列中的消息达到了设置的最大容量值后，队列会将处于队列前面的那些消息*(也就是比较旧的消息)* 移除或者放入"死信队列"。如果需要改变这种溢出处理策略，则可以通过队列参数 `overflow` 或者 `x-overflow` 进行修改。 

- `overflow` | `x-overflow` 定义队列溢出后数据处理策略

该参数有两个值 `drop-head` 和 `reject-publish`，默认是 `drop-head`。 如果被设置为 `reject-publish` 则如果收到新消息，则会直接拒绝并丢弃。如果这时生产者使用了 `publish confirm` 模式，则生产者会收到 `nack` 通知。 当一个生产者对应有多个消费者，如果其中一个消费者对应的队列满了，并且设置了 `overflow=reject-publish`，则生产者会收到 `nack` 通知

## 优先级队列

从 `3.5.0` 版本开始，RabbitMQ提供了优先级队列的实现。如果要实现优先级队列需要两部操作即可：

> 通过队列参数定义具有优先级性质的队列

	Map<String, Object> arguments = new HashMap<String, Object>();
    arguments.put("x-max-priority", 10);
    channel.queueDeclare(queueName, true, false, true, arguments);

通过设置队列参数 `x-max-priority` 设置队列的优先级，队列的优先级支持 **0~255** 的数值，推荐使用的范围是： **1~10**。 该属性设置的是该队列中的消息允许的 **最大优先级数值**，不支持使用 `policy` 设置，因为 `policy` 是可以随时更新改变的。

> 生产者推送消息的时候设置 `AMQP.BasicProperties` 的 `priority` 为该消息具体的优先级数值

	String[] messageAry = {"hello", "world", "test"};
    for (String message : messageAry) {
        AMQP.BasicProperties.Builder basicPropertiesBuilder = new AMQP.BasicProperties().builder();
        if ("test".equalsIgnoreCase(message)) {
            basicPropertiesBuilder.priority(6);
        }

        channel.basicPublish(EXCHANGE_NAME, ROUTING_KEY, basicPropertiesBuilder.build(), message.getBytes());
        System.out.println(String.format("send message[%s] over", message));
    }

该数值范围为 **0~255** 默认不设置的时候是 **0**。 如果超过对应的队列中 `x-max-priority` 设置的最大值，则会被强制设置为 `x-max-priority` 指定的最大值

> 如果使用优先级队列，你可能需要关注这些

- 使用优先级队列，会存在内存、磁盘以及CPU的额外消耗，设置的优先级越高，消耗越大
- 如果消费者消费能力很强，可能不会有队列对其中的消息进行优先级排序的时间，那么这个时候或许结果看起来，设置的优先级并没有起到作用。 因此，通常会使用 `channel.basicQos(1)` 设置 `prefetch`
- **当优先级和TTL同时使用时**，可能会造成低优先级的已过期消息会被阻塞在高优先级未过期的消息后面，这些已过期的消息不会被传递给消费者，并且会计入队列的统计数据中
- **当优先级和队列最大限制一起使用时**，可能会造成当队列达到最大限制时，还未消费的高优先级的消息被移除丢弃

## 队列懒加载

RabbitMQ从`3.6.0` 版本开始，RabbitMQ引入了懒加载队列的概念

> RAM内存警报

 默认情况下，RabbitMQ会时实时监控该服务使用内存的情况，当使用的内存超过服务所在计算机的总RAM内存的**40%**时，就会触发内存警报，此时RabbitMQ就会阻塞所有正在推送消息的连接直到内存警报解除。 出现内存警报时， RabbitMQ会将消息尽量的移出到硬盘上来解决RAM内存占用过多问题。 你可以通过修改配置文件来更改默认的阀值，**默认是0.4，即 40%**

	vm_memory_high_watermark.relative = 0.4

当然，你也可以设置一个绝对的值，单位是：byte

	vm_memory_high_watermark.absolute = 1073741824

内存阀值也可以在broker运行期间通过命令行设置进行更改：

- `rabbitmqctl set_vm_memory_high_watermark [fraction]`：设置相对值
- `rabbitmqctl set_vm_memory_high_watermark absolute [memory_limit]`：设置绝对值

如果想要立刻解决内存警报，全局停止所有的消息传送，那么可以设置内存阀值为 `0`

	rabbitmqctl set_vm_memory_high_watermark 0

> 缩减RAM占用

为了解决RAM内存占用过多的问题，RabbitMQ在内存占用达到上述设置的内存阀值的50%的时候，就会开始将消息内容从队列中移出到硬盘保存的工作 *(持久化消息在接收的时候就已经保存到硬盘，此时会清除持久化消息在RAM内存中的副本)*。 这个阀值也可以配置文件修改，默认值是0.5：

	vm_memory_high_watermark_paging_ratio = 0.75

该值也可以设置为一个大于 `1` 的数值，这时该值就不会起作用



	







